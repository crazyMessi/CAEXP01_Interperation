[TOC]



#### 前言

​	VBO可以理解为一段由内存发送到GPU显存中的数据。刚开始，我跟着learnopengl用数组来存储这段数据，后来发现这样不是很方便，比如索引的时候容易岔位。于是本着研究2小时，省时5分钟的原则，折腾了一晚上，找到了看起来更方便点的解决方案，也就是用**vector\<glm::vecx\>**来存储这段数据。

​	

#### 最终成果：

​	在开始之前得明确一点，要找的替代品必须是在内存中连续存储的。否则我还得在着色器里对传来的数据再处理一下。反过来说，只要能有个数据结构是连续存储在内存里的，就可以考虑用来存这段数据。

​	最后，的解决方案如下：

##### 顶点

​	对于顶点的存储方式，从数组中的**连续三个浮点变量**，进化到了**结构体变量**，再进化到了glm库中的现成定义类型——向量，也就是**glm::vecx（x是向量的维度）**。这样就可以直接对容器里的顶点进行矩阵运算了。

##### 容器

​	容器由一开始的浮点数组，变成了stl里的**vector\<T\>**。

​	

​	结果本身其实意义不大，新的容器只是方便了一些逻辑思维能力不强的人（比如我自己）对顶点进行索引。顶点的存储改成了glm库里的向量，这倒是方便了很多，但这还得归功于写glm的人hh。

​	最大的收获在于，这个寻找替代品的过程让我深刻地意识到，我的c++学得是多么烂，以至于一大堆基础概念都没整明白。



#### 新的理解

##### 结构体变量&类

​	接触类这个概念也有一年半了，也是今天才了解了一下类的存储方式。

​	类其实就是函数+成员变量。而在内存中，申明类的一个对象，只是为一个变量开辟一段**连续**内存，这段内存里放的**只有类的成员变量**。类的静态变量和函数是单独存储的，而且只有一份。对象的内存里并没有函数，只是编译器可以通过对象访问类里的公有函数。另外，对象内部的数据是默认不公开的。

​	结构体和类类似，区别在于一个结构体实例中的数据是默认可以随意访问的，所以很多时候结构体比较方便。

​	此前不敢用结构体变量来存一个顶点，是害怕它不干净，会有一些杂七杂八的东西。其实根本没有。**如果一个类或结构体的成员变量类型都相同**，那甚至可以把它的一个实例看作一个数组，只是这个数组的索引方式由原来的index变成了成员变量的名字而已。

```c++
struct vec3Point {
	float x;
	float y;
	float z;
};
...
vec3Point sv = { 0.0,1.1f,2.2f };
cout << &sv.x<<endl;
cout << &sv.y << endl;
cout << &sv.z << endl;
```

>*运行结果*：
>
>0053F814
>0053F818
>0053F81C

可以看到，这里就是三块连续的四字节浮点数。也就是说，结构体变量完全可以直接发送给着色器。我们也可以在着色器里用GLSL中结构体变量来接收内存发过来的结构体，无缝衔接说的就是这吧。



而glm中定义的向量、矩阵，恰好就是结构体变量。glm::vec3的源码有四百多行，但其实一个实例只占12个字节，说明其实就是由三个浮点数来组成的。



*关于结构体中不同类型的成员变量在内存里的存储方式，可以参考这篇博客。[结构体在内存中是如何存储的](https://blog.csdn.net/liuwei271551048/article/details/25789817)，里面提到了分配内存的两个原则*

​	

##### SLT中的vector

​	vector是一个动态的数组，既然是数组，那应该是连续存储的。但在刚开始，我在循环体中向vector 插入（push_back（））一个glm::vec3，然后打印这个变量的地址，以验证这一点时——vec3是三个浮点数，那么打印的结果就应该是步长为12的等差数列——结果却并非如此：

```c++
vector<glm::vec3> v;
...
for (size_t i = 0; i < 10; i++)
		v.push_back(glm::vec3());
		cout << &v[i]<<endl;
}
```

>输出：
>
>00AB2618
>00B69394
>04941140
>0968A11C
>04963B10
>04963B1C
>0488A2E0
>0488A2EC
>0488A2F8
>047A587C

看上去是随机存储的。难道是stl在骗我？我一度放弃了使用vector来作为容器。后来发现并不是只有我存在这个疑问。参考问题：

[Are std::vector elements guaranteed to be contiguous？](https://stackoverflow.com/questions/849168/are-stdvector-elements-guaranteed-to-be-contiguous)

大致意思就是，vector会在每次插入后重新规划数组。所以说，vector只是擅长随机访问的，它随机插入的效率并不高。（写stl的人真爱折腾，但人家毕竟是大佬我也不好去质疑他）

装bool变量的vector会有些不一样。除此以外vector内的数据就是放在一个数组里的。



于是换种方式尝试了一下：初始化完毕后再取一次址。

```c++
...
cout << "2:" << endl;
for (size_t i = 0; i < 10; i++) {

    cout << &v[i] << endl;
}
```

>00F63698
>0100E22C
>09CBBE80
>09D0B304
>04EF0590
>04EF059C
>04EF2378
>04EF2384
>04EF2390
>04EEBD34
>2:
>04EEBCC8
>04EEBCD4
>04EEBCE0
>04EEBCEC
>04EEBCF8
>04EEBD04
>04EEBD10
>04EEBD1C
>04EEBD28
>04EEBD34

stl诚不欺我，vector里真的放了一个正儿八经的数组！不过这个数组的首地址不是容器本身。

debug一下看看这个数组被放在了哪

（顺便夸一下vs的监视器，看哭我了，真就宇宙第一ide）

![image-20210406201954190](%E5%85%B3%E4%BA%8EVBO%E7%9A%84%E9%80%89%E6%8B%A9.assets/image-20210406201954190.png)

可以看到，v的首地址和v[0]完全不是一回事。一个vector内除了数组以外，还有一个整形变量，以及三个常用的指针，first，last，end。last指针指向最后一个元素，而end指针指向末尾元素后几个位置，这应该是预留的空间。

​	至此，我们可以在绑定VBO时，采用一些更优雅的姿势了。



​    这里有个小插曲，我发现一个vec3里好像有9个浮点数，顿时惊出一身冷汗。

​	定睛一看才发现，这vec3里放的刚好就是x，y，z；r，g，b；s，t，p。翻译翻译，可不就是坐标、rgb、纹理吗，这像是给一个变量起了三个名字，我一拍脑袋，可不就是引用吗。

​	然而不是，glm是用c写的。点进去看了看，大佬们用union实现了和引用一样的效果

```C
//vec3的data域
//每一个union体中的三个变量共用那段字节
union { T x, r, s; };
union { T y, g, t; };
union { T z, b, p; };
```

​	如果觉得自己用不上这么多名字的话，可以把后两个变量删去（debug的时候会清楚很多），实测使用无碍。



---













​	